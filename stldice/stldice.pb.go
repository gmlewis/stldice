// Code generated by protoc-gen-go.
// source: stldice.proto
// DO NOT EDIT!

/*
Package stldice is a generated protocol buffer package.

It is generated from these files:
	stldice.proto

It has these top-level messages:
	VoxelRegion
	AddSTLMeshRequest
	AddSTLMeshReply
	SubSTLMeshRequest
	SubSTLMeshReply
	GetSTLMeshRequest
	GetSTLMeshReply
*/
package stldice

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type VoxelRegion struct {
	// Minimum Bounding Box (MBB) of region to be voxelized (in millimeters).
	Llx float64 `protobuf:"fixed64,1,opt,name=llx" json:"llx,omitempty"`
	Lly float64 `protobuf:"fixed64,2,opt,name=lly" json:"lly,omitempty"`
	Llz float64 `protobuf:"fixed64,3,opt,name=llz" json:"llz,omitempty"`
	Urx float64 `protobuf:"fixed64,4,opt,name=urx" json:"urx,omitempty"`
	Ury float64 `protobuf:"fixed64,5,opt,name=ury" json:"ury,omitempty"`
	Urz float64 `protobuf:"fixed64,6,opt,name=urz" json:"urz,omitempty"`
	// Number of voxels to process in this subregion. Note that voxels are uniform
	// dimensions on all three axes.
	Nx int64 `protobuf:"varint,7,opt,name=nx" json:"nx,omitempty"`
	Ny int64 `protobuf:"varint,8,opt,name=ny" json:"ny,omitempty"`
	Nz int64 `protobuf:"varint,9,opt,name=nz" json:"nz,omitempty"`
}

func (m *VoxelRegion) Reset()                    { *m = VoxelRegion{} }
func (m *VoxelRegion) String() string            { return proto.CompactTextString(m) }
func (*VoxelRegion) ProtoMessage()               {}
func (*VoxelRegion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *VoxelRegion) GetLlx() float64 {
	if m != nil {
		return m.Llx
	}
	return 0
}

func (m *VoxelRegion) GetLly() float64 {
	if m != nil {
		return m.Lly
	}
	return 0
}

func (m *VoxelRegion) GetLlz() float64 {
	if m != nil {
		return m.Llz
	}
	return 0
}

func (m *VoxelRegion) GetUrx() float64 {
	if m != nil {
		return m.Urx
	}
	return 0
}

func (m *VoxelRegion) GetUry() float64 {
	if m != nil {
		return m.Ury
	}
	return 0
}

func (m *VoxelRegion) GetUrz() float64 {
	if m != nil {
		return m.Urz
	}
	return 0
}

func (m *VoxelRegion) GetNx() int64 {
	if m != nil {
		return m.Nx
	}
	return 0
}

func (m *VoxelRegion) GetNy() int64 {
	if m != nil {
		return m.Ny
	}
	return 0
}

func (m *VoxelRegion) GetNz() int64 {
	if m != nil {
		return m.Nz
	}
	return 0
}

// Add an STL mesh to the voxels (possibly a subregion on the slave).
type AddSTLMeshRequest struct {
	VoxelRegion *VoxelRegion `protobuf:"bytes,1,opt,name=voxel_region,json=voxelRegion" json:"voxel_region,omitempty"`
	// STL file to voxelize and add to the voxel model.
	StlFile []byte `protobuf:"bytes,2,opt,name=stl_file,json=stlFile,proto3" json:"stl_file,omitempty"`
}

func (m *AddSTLMeshRequest) Reset()                    { *m = AddSTLMeshRequest{} }
func (m *AddSTLMeshRequest) String() string            { return proto.CompactTextString(m) }
func (*AddSTLMeshRequest) ProtoMessage()               {}
func (*AddSTLMeshRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AddSTLMeshRequest) GetVoxelRegion() *VoxelRegion {
	if m != nil {
		return m.VoxelRegion
	}
	return nil
}

func (m *AddSTLMeshRequest) GetStlFile() []byte {
	if m != nil {
		return m.StlFile
	}
	return nil
}

type AddSTLMeshReply struct {
}

func (m *AddSTLMeshReply) Reset()                    { *m = AddSTLMeshReply{} }
func (m *AddSTLMeshReply) String() string            { return proto.CompactTextString(m) }
func (*AddSTLMeshReply) ProtoMessage()               {}
func (*AddSTLMeshReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Subtract an STL mesh from the voxels (possibly a subregion on the slave).
type SubSTLMeshRequest struct {
	VoxelRegion *VoxelRegion `protobuf:"bytes,1,opt,name=voxel_region,json=voxelRegion" json:"voxel_region,omitempty"`
	// STL file to voxelize and subtract from the voxel model.
	StlFile []byte `protobuf:"bytes,2,opt,name=stl_file,json=stlFile,proto3" json:"stl_file,omitempty"`
}

func (m *SubSTLMeshRequest) Reset()                    { *m = SubSTLMeshRequest{} }
func (m *SubSTLMeshRequest) String() string            { return proto.CompactTextString(m) }
func (*SubSTLMeshRequest) ProtoMessage()               {}
func (*SubSTLMeshRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SubSTLMeshRequest) GetVoxelRegion() *VoxelRegion {
	if m != nil {
		return m.VoxelRegion
	}
	return nil
}

func (m *SubSTLMeshRequest) GetStlFile() []byte {
	if m != nil {
		return m.StlFile
	}
	return nil
}

type SubSTLMeshReply struct {
}

func (m *SubSTLMeshReply) Reset()                    { *m = SubSTLMeshReply{} }
func (m *SubSTLMeshReply) String() string            { return proto.CompactTextString(m) }
func (*SubSTLMeshReply) ProtoMessage()               {}
func (*SubSTLMeshReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// Get back the model voxels as STL (possibly a subregion on the slave).
// This also resets the server by clearing out the model.
type GetSTLMeshRequest struct {
	VoxelRegion *VoxelRegion `protobuf:"bytes,1,opt,name=voxel_region,json=voxelRegion" json:"voxel_region,omitempty"`
}

func (m *GetSTLMeshRequest) Reset()                    { *m = GetSTLMeshRequest{} }
func (m *GetSTLMeshRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSTLMeshRequest) ProtoMessage()               {}
func (*GetSTLMeshRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetSTLMeshRequest) GetVoxelRegion() *VoxelRegion {
	if m != nil {
		return m.VoxelRegion
	}
	return nil
}

type GetSTLMeshReply struct {
	// Resulting STL mesh from the voxel model subregion.
	StlFile []byte `protobuf:"bytes,1,opt,name=stl_file,json=stlFile,proto3" json:"stl_file,omitempty"`
}

func (m *GetSTLMeshReply) Reset()                    { *m = GetSTLMeshReply{} }
func (m *GetSTLMeshReply) String() string            { return proto.CompactTextString(m) }
func (*GetSTLMeshReply) ProtoMessage()               {}
func (*GetSTLMeshReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetSTLMeshReply) GetStlFile() []byte {
	if m != nil {
		return m.StlFile
	}
	return nil
}

func init() {
	proto.RegisterType((*VoxelRegion)(nil), "stldice.VoxelRegion")
	proto.RegisterType((*AddSTLMeshRequest)(nil), "stldice.AddSTLMeshRequest")
	proto.RegisterType((*AddSTLMeshReply)(nil), "stldice.AddSTLMeshReply")
	proto.RegisterType((*SubSTLMeshRequest)(nil), "stldice.SubSTLMeshRequest")
	proto.RegisterType((*SubSTLMeshReply)(nil), "stldice.SubSTLMeshReply")
	proto.RegisterType((*GetSTLMeshRequest)(nil), "stldice.GetSTLMeshRequest")
	proto.RegisterType((*GetSTLMeshReply)(nil), "stldice.GetSTLMeshReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for STLDice service

type STLDiceClient interface {
	// Add an STL mesh to the voxels (possibly a subregion on the slave).
	AddSTLMesh(ctx context.Context, in *AddSTLMeshRequest, opts ...grpc.CallOption) (*AddSTLMeshReply, error)
	// Subtract an STL mesh from the voxels (possibly a subregion on the slave).
	SubSTLMesh(ctx context.Context, in *SubSTLMeshRequest, opts ...grpc.CallOption) (*SubSTLMeshReply, error)
	// Get back the model voxels as STL (possibly a subregion on the slave).
	// This also resets the server by clearing out the model.
	GetSTLMesh(ctx context.Context, in *GetSTLMeshRequest, opts ...grpc.CallOption) (*GetSTLMeshReply, error)
}

type sTLDiceClient struct {
	cc *grpc.ClientConn
}

func NewSTLDiceClient(cc *grpc.ClientConn) STLDiceClient {
	return &sTLDiceClient{cc}
}

func (c *sTLDiceClient) AddSTLMesh(ctx context.Context, in *AddSTLMeshRequest, opts ...grpc.CallOption) (*AddSTLMeshReply, error) {
	out := new(AddSTLMeshReply)
	err := grpc.Invoke(ctx, "/stldice.STLDice/AddSTLMesh", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sTLDiceClient) SubSTLMesh(ctx context.Context, in *SubSTLMeshRequest, opts ...grpc.CallOption) (*SubSTLMeshReply, error) {
	out := new(SubSTLMeshReply)
	err := grpc.Invoke(ctx, "/stldice.STLDice/SubSTLMesh", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sTLDiceClient) GetSTLMesh(ctx context.Context, in *GetSTLMeshRequest, opts ...grpc.CallOption) (*GetSTLMeshReply, error) {
	out := new(GetSTLMeshReply)
	err := grpc.Invoke(ctx, "/stldice.STLDice/GetSTLMesh", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for STLDice service

type STLDiceServer interface {
	// Add an STL mesh to the voxels (possibly a subregion on the slave).
	AddSTLMesh(context.Context, *AddSTLMeshRequest) (*AddSTLMeshReply, error)
	// Subtract an STL mesh from the voxels (possibly a subregion on the slave).
	SubSTLMesh(context.Context, *SubSTLMeshRequest) (*SubSTLMeshReply, error)
	// Get back the model voxels as STL (possibly a subregion on the slave).
	// This also resets the server by clearing out the model.
	GetSTLMesh(context.Context, *GetSTLMeshRequest) (*GetSTLMeshReply, error)
}

func RegisterSTLDiceServer(s *grpc.Server, srv STLDiceServer) {
	s.RegisterService(&_STLDice_serviceDesc, srv)
}

func _STLDice_AddSTLMesh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSTLMeshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(STLDiceServer).AddSTLMesh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stldice.STLDice/AddSTLMesh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(STLDiceServer).AddSTLMesh(ctx, req.(*AddSTLMeshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _STLDice_SubSTLMesh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubSTLMeshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(STLDiceServer).SubSTLMesh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stldice.STLDice/SubSTLMesh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(STLDiceServer).SubSTLMesh(ctx, req.(*SubSTLMeshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _STLDice_GetSTLMesh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSTLMeshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(STLDiceServer).GetSTLMesh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stldice.STLDice/GetSTLMesh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(STLDiceServer).GetSTLMesh(ctx, req.(*GetSTLMeshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _STLDice_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stldice.STLDice",
	HandlerType: (*STLDiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddSTLMesh",
			Handler:    _STLDice_AddSTLMesh_Handler,
		},
		{
			MethodName: "SubSTLMesh",
			Handler:    _STLDice_SubSTLMesh_Handler,
		},
		{
			MethodName: "GetSTLMesh",
			Handler:    _STLDice_GetSTLMesh_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stldice.proto",
}

func init() { proto.RegisterFile("stldice.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 322 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x93, 0xbf, 0x4e, 0xc3, 0x30,
	0x18, 0xc4, 0xeb, 0x16, 0xda, 0xf2, 0xb5, 0x50, 0x62, 0x31, 0x98, 0x4e, 0x55, 0xa6, 0x0e, 0xa8,
	0x43, 0x19, 0x98, 0x91, 0x2a, 0x58, 0xc2, 0xe2, 0x54, 0xac, 0x95, 0xda, 0x98, 0x12, 0xc9, 0x4a,
	0x42, 0xfe, 0x54, 0xb6, 0xdf, 0x88, 0x67, 0xe2, 0x65, 0x90, 0x9d, 0x84, 0xb8, 0x0d, 0x23, 0x62,
	0xcb, 0xfd, 0x22, 0xdd, 0x7d, 0x77, 0x51, 0xe0, 0x32, 0xcb, 0x79, 0x10, 0xee, 0xd8, 0x22, 0x49,
	0xe3, 0x3c, 0xc6, 0x83, 0x4a, 0xba, 0x9f, 0x08, 0x46, 0xaf, 0xb1, 0x60, 0x9c, 0xb2, 0x7d, 0x18,
	0x47, 0xf8, 0x1a, 0x7a, 0x9c, 0x0b, 0x82, 0x66, 0x68, 0x8e, 0xa8, 0x7e, 0x2c, 0x89, 0x24, 0xdd,
	0x9a, 0xc8, 0x92, 0x28, 0xd2, 0xab, 0x89, 0xd2, 0xa4, 0x48, 0x05, 0x39, 0x2b, 0x49, 0x91, 0x8a,
	0x92, 0x48, 0x72, 0x5e, 0x13, 0x59, 0x12, 0x45, 0xfa, 0x35, 0x51, 0xf8, 0x0a, 0xba, 0x91, 0x20,
	0x83, 0x19, 0x9a, 0xf7, 0x68, 0x37, 0x12, 0x46, 0x4b, 0x32, 0xac, 0xb4, 0x34, 0x5a, 0x91, 0x8b,
	0x4a, 0x2b, 0x77, 0x0f, 0xce, 0x63, 0x10, 0xf8, 0x6b, 0xef, 0x85, 0x65, 0xef, 0x94, 0x7d, 0x14,
	0x2c, 0xcb, 0xf1, 0x03, 0x8c, 0x0f, 0xfa, 0xfe, 0x4d, 0x6a, 0x0a, 0x98, 0xcb, 0x47, 0xcb, 0x9b,
	0x45, 0xdd, 0xd7, 0x2a, 0x47, 0x47, 0x07, 0xab, 0xe9, 0x2d, 0x0c, 0xb3, 0x9c, 0x6f, 0xde, 0x42,
	0xce, 0x4c, 0xb9, 0x31, 0xd5, 0xa3, 0x3c, 0x85, 0x9c, 0xb9, 0x0e, 0x4c, 0xec, 0xa0, 0x84, 0x4b,
	0x9d, 0xed, 0x17, 0xdb, 0xff, 0xc9, 0xb6, 0x83, 0x74, 0xb6, 0x07, 0xce, 0x33, 0xcb, 0xff, 0x28,
	0xdb, 0xbd, 0x83, 0x89, 0xed, 0x96, 0x70, 0x79, 0x74, 0x0e, 0x3a, 0x3a, 0x67, 0xf9, 0x85, 0x60,
	0xe0, 0xaf, 0xbd, 0x55, 0xb8, 0x63, 0x78, 0x05, 0xd0, 0xcc, 0x82, 0xa7, 0x3f, 0x51, 0xad, 0x8f,
	0x32, 0x25, 0xbf, 0xbe, 0xd3, 0x5d, 0x3a, 0xda, 0xa5, 0x29, 0x68, 0xb9, 0xb4, 0xe6, 0xb5, 0x5c,
	0x4e, 0x17, 0x31, 0x2e, 0x4d, 0x0b, 0xcb, 0xa5, 0x35, 0x94, 0xe5, 0x72, 0x52, 0xdb, 0xed, 0x6c,
	0xfb, 0xe6, 0x6f, 0xb8, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x15, 0x5a, 0x6f, 0xde, 0x1e, 0x03,
	0x00, 0x00,
}
